<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="vaadin-grid-table.html">
<link rel="import" href="vaadin-grid-column.html">
<link rel="import" href="vaadin-grid-column-group.html">
<link rel="import" href="vaadin-grid-row-details-behavior.html">
<link rel="import" href="vaadin-grid-data-source-behavior.html">
<link rel="import" href="vaadin-grid-selection-behavior.html">

<dom-module id="vaadin-grid">
  <style>
    :host {
      display: block;
      height: 400px;
      /* default height to avoid accidental usage without explicit height */
      --vaadin-grid-border-color: rgba(0, 0, 0, 0.08);

      -webkit-tap-highlight-color: transparent;
    }

    #scroller {
      border: 1px solid var(--vaadin-grid-border-color);
      height: 100%;
      width: 100%;
    }
  </style>
  <template>
    <vaadin-grid-table loading$=[[loading]] bind-data="[[_bindData]]" size="[[size]]" id="scroller" columns="[[_columns]]" frozen-columns=[[_frozenColumns]] content-target=[[_getContentTarget()]] row-details-template=[[rowDetailsTemplate]]>
      <content></content>
    </vaadin-grid-table>
  </template>
</dom-module>

<script>
  Polymer({
    is: 'vaadin-grid',

    properties: {

      _columns: {
        type: Array,
        notify: true
      },

      size: Number,

      _frozenColumns: {
        type: Number,
        value: 0
      },

      rowDetailsTemplate: Object,

      _bindData: {
        value: function() {
          return this._getItem.bind(this);
        }
      }
    },

    behaviors: [
      vaadin.elements.grid.RowDetailsBehavior,
      vaadin.elements.grid.DataSourceBehavior,
      vaadin.elements.grid.SelectionBehavior
    ],

    observers: ['_columnsChanged(_columns.*)'],

    _updateItem: function(row, item) {
      row.style.minHeight = item ? '' : this.$.scroller._physicalAverage + 'px';
      row.item = item;
      row.selected = this._isSelected(item);
      row.expanded = this._isExpanded(item);
    },

    _getContentTarget: function() {
      return this;
    },

    _isFrozenColumn: function(column) {
      return this._columns.indexOf(column) < this._frozenColumns;
    },

    ready: function() {
      // this.columns = Polymer.dom(this).querySelectorAll('vaadin-grid-column');
      this._columns = this._getColumns(Polymer.dom(this).children);
      this._frozenColumns = this._columns.reduce(function(count, column) {
        return count + column.hasAttribute('frozen') ? 1 : 0;
      }, 0);

      this.rowDetailsTemplate = Polymer.dom(this).querySelector('template[is=row-details]');
    },

    _getColumns: function (children) {

      var result = [].reduce.call(children, function(array, child) {
        if (child.tagName.toLowerCase() === 'vaadin-grid-column') {
          array.push(child);
        } else if (child.tagName.toLowerCase() === 'vaadin-grid-column-group') {
          var groupColumns = this._getColumns(child.children);
          var groupTemplate = child.querySelector('template[is="header"]');
          groupTemplate.setAttribute('colspan', groupColumns.length);
          Polymer.dom(groupColumns[0]).insertBefore(groupTemplate, groupColumns[0].firstChild);
          array = array.concat(groupColumns);
        }
        return array;
      }.bind(this), []);

      var rows = [].reduce.call(result, function(prev, curr) {
        return Math.max(prev, curr.querySelectorAll('template[is="header"]').length);
      }, 0);
      result.forEach(function(column) {
        while (column.querySelectorAll('template[is="header"]').length < rows) {
          var emptyTemplate = document.createElement('template');
          emptyTemplate.setAttribute('is', 'header');
          Polymer.dom(column).insertBefore(emptyTemplate, column.firstChild);
        }
      });

      return result;
    },

    _columnsChanged: function(e) {
      if (e.path === '_columns') { //new array is set
        e.value.forEach(function(col) {
          col.grid = this;
        }.bind(this));
      } else if (e.path === '_columns.splices' || //array is spliced
        (e.path.indexOf('_columns.#') === 0 && e.path.split('.').length === 2)) { //column is replaced with set
        // TODO: implement splice support that will add and remove only affected cells.
        // meanwhile, deal with splices as the whole array would change.
        this._columns = this._columns.slice(0);
      }
    }
  });
</script>
